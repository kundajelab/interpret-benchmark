#!/usr/bin/env python
from __future__ import division, absolute_import, print_function
import argparse
from collections import OrderedDict, defaultdict, namedtuple
import json
from vakai.motifhit import motifhit_from_str 


def read_sequences_and_motifs_file(sequences_and_motifs_file):
    #TODO: verify that sequence predicted by motifhit lines up with what's
    # actually in the sequence at that position
    pass


def get_motif_to_length(motifs_in_seqs):
    pass


def get_motif_to_pos_windows(motifs_in_seqs, seqlens):
    raise RuntimeError()


def get_length_to_neg_windows(motifs_in_seqs, lengths, seqlens):
    #create an 'occupied positions' array
    #use that to find windows of a given length that overlap no motifs
    raise RuntimeError()


def get_metric_to_perf(pos_windows, neg_windows, windowsummed_imp_scores):
    raise RuntimeError() #return auroc, auprc


def compute_windowsum(arr, windowlen):
    assert len(arr.shape)==2
    cumsum_arr = np.pad(array=np.cumsum(arr, axis=-1),
                           pad_width=((0,0),(1,0)),
                           mode='constant',
                           constant_values=0)
    assert cumsum_arr.shape==(arr.shape[0], arr.shape[1]+1)
    to_return = cumsum_scores[:,windowlen:]-cumsum_scores[:,0:-windowlen]
    assert to_return.shape==(arr.shape[0], arr.shape[1]-(arr-1))
    return to_return


def get_motif_to_metric_to_perf(motif_to_length, motif_to_pos_windows,
                                length_to_neg_windows, imp_scores):
    motif_to_detection_perf = {}
    for motif in motif_to_pos_windows:
        pos_windows = motif_to_pos_windows[motif]
        motif_length = motif_to_length[motif]
        neg_windows = length_to_neg_windows[motif_length]
        windowsummed_imp_scores = compute_windowsum(arr=imp_scores,
                                                    windowlen=motif_length)
        motif_to_metric_to_perf[motif] = get_metric_to_perf(
            pos_windows=pos_windows, neg_windows=neg_windows,
            windowsummed_imp_scores=windowsummed_imp_scores) 
    return motif_to_metric_to_perf


def compute_motif_detection_stats(args):

    seqids, onehot_sequences, motifs_in_seqs =\
        read_sequences_and_motifs_file(
            sequences_and_motifs_file=args.sequences_and_motifs)

    motif_to_length = get_motif_to_length(motifs=motifs) 
    motif_to_pos_windows = get_motif_to_pos_windows(
                            motifs_in_seqs=motifs_in_seqs,
                            seqlens=onehot_sequences.shape[2])
    length_to_neg_windows = get_length_to_neg_windows(
                             motifs_in_seqs=motifs_in_seqs, 
                             lengths=set(motif_to_length.values()),
                             seqlens=onehot_sequences.shape[2])

    method_to_motif_to_metric_to_perf = {}
    interpretation_h5 = h5py.File(args.interpretation_h5, "r")
    for key in interpretation_h5:
        if (key != "seqids"):
            imp_scores = np.array(interpretation_h5[key][:])
            motif_to_metric_to_perf = get_motif_to_metric_to_perf(
                motif_to_length=motif_to_length,
                motif_to_pos_windows=motif_to_pos_windows,
                length_to_neg_windows=length_to_neg_windows,
                imp_scores=imp_scores)
            method_to_motif_to_metric_to_perf[key] = motif_to_detection_perf
    interpretation_h5.close()

    #rearrange the dictionary to be metric_to_motif_to_method_to_perf:
    metric_to_motif_to_method_to_perf = defaultdict(lambda: defaultdict(dict))
    for method in method_to_motif_to_metric_to_perf:
        for motif in method_to_motif_to_metric_to_perf[method]:
            for metric in method_to_motif_to_metric_to_perf[method][motif]:
                metric_to_motif_to_method_to_perf[metric][motif][method] =\
                    method_to_motif_to_metric_to_perf[method][motif][metric]

    #json dump
    with out_fh as open(args.outfile, 'w'):
        out_fh.write(json.dumps(metric_to_motif_to_method_to_perf, indent=4))


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--sequences_and_motifs", required=True)
    parser.add_argument("--interpretation_h5", required=True)
    parser.add_argument("--outfile", required=True)
    args = parser.parse_args()
    compute_motif_detection_stats(args)
